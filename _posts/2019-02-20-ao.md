---
title: AO* in Swift
layout: post
date: 2019-02-20 22:50:53

---


This is an implementation of the AO* algorithm in Swift

```
    private func AOstarTraverse() -> Bool {
        guard !isFinal else { return true }
        guard !leadsToFinal else { return true }
        guard !isUnsolvable else { return false }
        
        // if the priority queue is nil, this is the first visit.
       // we only initialize it and update the estimate.
        guard let queue = Q else {
            expand()
            return leadsToFinal
        }
        
        // popping the least estimated operator,
        //if no operators left then this node is unsolvable.
        guard let op = queue.pop() else {
            isUnsolvable = true
            return false
        }
        
        // using AOStar to traverse each node from the operator,
        // then anding their results (must all be true)
        leadsToFinal = op.nodes.map { $0.AOstarTraverse() }.reduce(true, { $0 && $1 })
        estimate = op.estimatedCost
        
        // if an operator has a single unsolvable node,
        // no need to re-add it to the queue as it becomes useless.
        if !op.isUnsolvable {
            queue.push(op)
        }
        
        return leadsToFinal
    }
    
    private func expand() {
        Q = PriorityQueue(array: operators, sort: <)
        if operators.count == 0 && !isFinal {
            isUnsolvable = true
        }
        estimate = operators.map { $0.estimatedCost }.min() ?? 0
    }

``` 